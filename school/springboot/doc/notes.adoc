= Notes

== Conversation avec un GPT

**Spring sans orm avec r2dbc**

=== Implémentation d'un CRUD SpringBoot avec R2DBC sans ORM en Kotlin

**Objectif:** Créer une application CRUD simple avec SpringBoot, R2DBC et Kotlin, sans utiliser d'ORM comme Spring Data, Hibernate ou JOOQ. La gestion des transactions sera effectuée de manière programmatique avec des coroutines, sans annotations.

**Prérequis:**

* Kotlin
* SpringBoot
* R2DBC (ex: H2)
* Coroutines

**Fichier `build.gradle.kts`:**

```kotlin
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-webflux")
    implementation("io.r2dbc:r2dbc-h2")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
}
```

**Fichier `Application.kt`:**

```kotlin
@SpringBootApplication
class Application

fun main(args: Array<String>) {
    runApplication<Application>(*args)
}
```

**Fichier `DatabaseClient.kt`:**

```kotlin
class DatabaseClient(private val client: R2dbcDatabaseClient) {

    suspend fun <T> execute(sql: String, mapper: (row: Row) -> T): List<T> {
        return client.sql(sql).map { row -> mapper(row) }.collectList().await()
    }

    suspend fun execute(sql: String): Int {
        return client.sql(sql).then().await().rowsUpdated
    }
}
```

**Fichier `UserRepository.kt`:**

```kotlin
class UserRepository(private val db: DatabaseClient) {

    suspend fun findAll(): List<User> {
        return db.execute("SELECT * FROM users", ::toUser)
    }

    suspend fun findById(id: Int): User? {
        return db.execute("SELECT * FROM users WHERE id = $id", ::toUser).firstOrNull()
    }

    suspend fun save(user: User): Int {
        return db.execute(
            """
            INSERT INTO users (name, email)
            VALUES (${user.name}, ${user.email})
            """,
            ::toGeneratedKey
        )
    }

    suspend fun update(user: User): Int {
        return db.execute(
            """
            UPDATE users
            SET name = ${user.name}, email = ${user.email}
            WHERE id = ${user.id}
            """
        )
    }

    suspend fun delete(id: Int): Int {
        return db.execute("DELETE FROM users WHERE id = $id")
    }

    private fun toUser(row: Row): User {
        return User(
            row["id"] as Int,
            row["name"] as String,
            row["email"] as String
        )
    }

    private fun toGeneratedKey(row: Row): Int {
        return row["id"] as Int
    }
}
```

**Fichier `UserController.kt`:**

```kotlin
@RestController
@RequestMapping("/users")
class UserController(private val userRepository: UserRepository) {

    @GetMapping
    suspend fun findAll(): List<User> {
        return userRepository.findAll()
    }

    @GetMapping("/{id}")
    suspend fun findById(@PathVariable id: Int): User? {
        return userRepository.findById(id)
    }

    @PostMapping
    suspend fun save(@RequestBody user: User): Int {
        return userRepository.save(user)
    }

    @PutMapping("/{id}")
    suspend fun update(@PathVariable id: Int, @RequestBody user: User): Int {
        return userRepository.update(user.copy(id = id))
    }

    @DeleteMapping("/{id}")
    suspend fun delete(@PathVariable id: Int): Int {
        return userRepository.delete(id)
    }
}
```

**Data class `User.kt`:**

```kotlin
data class User(
    val id: Int,
    val name: String,
    val email: String
)
```

**Remarques:**

* Cette implémentation utilise R2DBC H2 comme base de données. Vous pouvez remplacer H2 par une autre implémentation R2DBC.
* La gestion des transactions est effectuée de manière programmatique avec des coroutines.
* Les requêtes SQL sont directement dans le code. Vous pouvez les extraire dans un fichier séparé pour plus de clarté.
* La conversion des résultats de la requête en objets Kotlin est effectuée manuellement avec des fonctions de mappage. Vous pouvez utiliser une bibliothèque comme `kotlinx-serialization` pour simplifier la sérialisation/désérialisation.
* Ce code est un exemple simple et ne gère pas les erreurs ou les cas limites. Vous devez le compléter pour une utilisation en production.

**Exemple d'utilisation:**

```kotlin
val user = User(
    name = "John Doe",
    email = "johndoe@example.com"
)

val userRepository = UserRepository(DatabaseClient(R2dbcDatabaseClient.create("r2dbc:h2:mem")))

// Sauvegarder l'utilisateur
val userId = userRepository.save(user)

// Trouver l'utilisateur par son ID
val user2 = userRepository.findById(userId)

// Mettre à jour l'utilisateur
user2?.name = "Jane Doe"
userRepository.update(user2!!)

// Supprimer l'utilisateur
userRepository.delete(userId)
```

**Conclusion:**

Cet exemple montre comment implémenter un CRUD simple avec SpringBoot, R2DBC et Kotlin sans utiliser d'ORM. La gestion des transactions est effectuée de manière programmatique avec des coroutines. This approach offers more flexibility and control compared to using annotations, but requires more manual coding.


=== Implémentation d'un CRUD avec SpringBoot, R2DBC et SQLDelight
.Une autre solution similaire

**Fichier `build.gradle.kts`:**

```kotlin
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-webflux")
    implementation("com.squareup.sqldelight:sqldelight-jdbc:1.5.3")
    implementation("com.squareup.sqldelight:sqldelight-r2dbc:1.5.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
}
```

**Fichier `Application.kt`:**

```kotlin
@SpringBootApplication
class Application

fun main(args: Array<String>) {
    runApplication<Application>(*args)
}
```

**Fichier `Database.db` (fichier SQLDelight):**

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL
);
```

**Fichier `Database.kt`:**

```kotlin
import com.squareup.sqldelight.db.SqlDriver
import com.squareup.sqldelight.drivers.r2dbc.R2dbcDriver

class Database(private val driver: SqlDriver) {

    val users = DatabaseQueries(driver)

    suspend fun <T> execute(sql: String, mapper: (row: QueryRow) -> T): List<T> {
        return driver.executeQuery(sql, mapper)
    }

    suspend fun execute(sql: String): Int {
        return driver.execute(sql)
    }
}
```

**Fichier `UserRepository.kt`:**

```kotlin
class UserRepository(private val db: Database) {

    suspend fun findAll(): List<User> {
        return db.execute("SELECT * FROM users", ::toUser)
    }

    suspend fun findById(id: Int): User? {
        return db.execute("SELECT * FROM users WHERE id = $id", ::toUser).firstOrNull()
    }

    suspend fun save(user: User): Int {
        return db.users.insert(user.name, user.email)
    }

    suspend fun update(user: User): Int {
        return db.users.update(user.id, user.name, user.email)
    }

    suspend fun delete(id: Int): Int {
        return db.users.delete(id)
    }

    private fun toUser(row: QueryRow): User {
        return User(
            row.get("id"),
            row.get("name"),
            row.get("email")
        )
    }
}
```

**Fichier `UserController.kt`:**

```kotlin
@RestController
@RequestMapping("/users")
class UserController(private val userRepository: UserRepository) {

    @GetMapping
    suspend fun findAll(): List<User> {
        return userRepository.findAll()
    }

    @GetMapping("/{id}")
    suspend fun findById(@PathVariable id: Int): User? {
        return userRepository.findById(id)
    }

    @PostMapping
    suspend fun save(@RequestBody user: User): Int {
        return userRepository.save(user)
    }

    @PutMapping("/{id}")
    suspend fun update(@PathVariable id: Int, @RequestBody user: User): Int {
        return userRepository.update(user.copy(id = id))
    }

    @DeleteMapping("/{id}")
    suspend fun delete(@PathVariable id: Int): Int {
        return userRepository.delete(id)
    }
}
```

**Data class `User.kt`:**

```kotlin
data class User(
    val id: Int,
    val name: String,
    val email: String
)
```

**Remarques:**

* Cette implémentation utilise SQLDelight pour générer les requêtes SQL et mapper les résultats de la requête aux objets Kotlin.
* La gestion des transactions est effectuée de manière programmatique avec des coroutines.
* Le code est plus concis et plus facile à lire que l'implémentation sans ORM.

**Avantages de l'utilisation de SQLDelight:**

* **Génération automatique des requêtes SQL:** SQLDelight génère automatiquement les requêtes SQL à partir de vos définitions de table